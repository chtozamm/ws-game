/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ (() => {

eval("var conn = new WebSocket(\"ws://\" + document.location.host + \"/ws\");\nvar GameState;\n(function (GameState) {\n    GameState[GameState[\"INITIALIZING\"] = 0] = \"INITIALIZING\";\n    GameState[GameState[\"RUNNING\"] = 1] = \"RUNNING\";\n})(GameState || (GameState = {}));\nvar currentGameState = GameState.INITIALIZING;\nvar game = {\n    localPlayerId: 0,\n    localPlayerSize: 0,\n    playerSpeed: 0,\n    worldHeight: 0,\n    worldWidth: 0,\n    players: {},\n    collectableItems: {},\n    collectableItemSize: 0,\n    score: 0,\n};\nfunction setPlayer(playerId, position) {\n    game.players[playerId] = { position: position };\n}\nfunction deletePlayer(playerId) {\n    delete game.players[playerId];\n}\nconn.onmessage = function (ev) {\n    var message = JSON.parse(ev.data);\n    switch (message.type) {\n        case \"init\":\n            var initData = message.data;\n            game.localPlayerId = initData.player_id;\n            game.localPlayerSize = initData.player_size;\n            game.playerSpeed = initData.player_speed;\n            game.worldWidth = initData.world_width;\n            game.worldHeight = initData.world_height;\n            game.players = initData.players;\n            game.collectableItems = initData.collectable_items;\n            game.collectableItemSize = initData.collectable_item_size;\n            game.score = initData.score;\n            currentGameState = GameState.RUNNING;\n            break;\n        case \"connect\":\n            var connectData = message.data;\n            setPlayer(connectData.id, {\n                x: connectData.position.x,\n                y: connectData.position.y,\n            });\n            break;\n        case \"disconnect\":\n            deletePlayer(message.data);\n            break;\n        case \"pos_update\":\n            var posUpdateData = message.data;\n            setPlayer(posUpdateData.id, {\n                x: posUpdateData.position.x,\n                y: posUpdateData.position.y,\n            });\n            break;\n        case \"collect_item\":\n            delete game.collectableItems[message.data];\n            game.score++;\n            break;\n    }\n};\nvar canvas = document.getElementById(\"gameCanvas\");\ncanvas.width = window.innerWidth;\ncanvas.height = window.innerHeight;\nvar camera = {\n    x: 0,\n    y: 0,\n};\nvar keysPressed = {};\nvar KEY_W = \"w\";\nvar KEY_A = \"a\";\nvar KEY_S = \"s\";\nvar KEY_D = \"d\";\nvar KEY_UP = \"ArrowUp\";\nvar KEY_DOWN = \"ArrowDown\";\nvar KEY_LEFT = \"ArrowLeft\";\nvar KEY_RIGHT = \"ArrowRight\";\naddEventListener(\"keydown\", function (ev) {\n    keysPressed[ev.key] = true;\n});\naddEventListener(\"keyup\", function (ev) {\n    keysPressed[ev.key] = false;\n});\nvar joystick = document.getElementById(\"joystick\");\nvar joystickActive = false;\nvar joystickCenter = { x: 0, y: 0 };\nvar joystickThumb = document.getElementById(\"joystick-thumb\");\nvar moveX = 0;\nvar moveY = 0;\naddEventListener('gesturestart', function (e) {\n    e.preventDefault();\n});\nvar action1Button = document.getElementById('action1');\nvar action2Button = document.getElementById('action2');\naction1Button.addEventListener('click', function () {\n    // Implement Action 1 logic\n    console.log('Action 1 triggered');\n});\naction2Button.addEventListener('click', function () {\n    // Implement Action 2 logic\n    console.log('Action 2 triggered');\n});\naddEventListener(\"touchstart\", function (ev) {\n    ev.preventDefault();\n    var touch = ev.touches[0];\n    joystickCenter.x = touch.clientX;\n    joystickCenter.y = touch.clientY;\n    joystick.style.left = \"\".concat(joystickCenter.x - 50, \"px\"); // Center the joystick\n    joystick.style.top = \"\".concat(joystickCenter.y - 50, \"px\");\n    joystick.style.display = \"block\"; // Show the joystick\n    joystickActive = true;\n    // Reset thumb position\n    joystickThumb.style.left = \"50%\";\n    joystickThumb.style.top = \"50%\";\n});\naddEventListener(\"touchmove\", function (ev) {\n    if (!joystickActive)\n        return;\n    var touch = ev.touches[0];\n    var dx = touch.clientX - joystickCenter.x;\n    var dy = touch.clientY - joystickCenter.y;\n    var length = Math.sqrt(dx * dx + dy * dy);\n    var maxDistance = 50; // Max distance from the center\n    if (length > maxDistance) {\n        dx = (dx / length) * maxDistance;\n        dy = (dy / length) * maxDistance;\n    }\n    // Update thumb position\n    joystickThumb.style.left = \"\".concat(50 + (dx / maxDistance) * 50, \"%\"); // Centered at 50%\n    joystickThumb.style.top = \"\".concat(50 + (dy / maxDistance) * 50, \"%\"); // Centered at 50%\n    // Update player movement based on joystick position\n    moveX = dx / maxDistance;\n    moveY = dy / maxDistance;\n});\naddEventListener(\"touchend\", function () {\n    joystick.style.display = \"none\"; // Hide the joystick\n    joystickActive = false;\n    // Reset thumb position\n    joystickThumb.style.left = \"50%\";\n    joystickThumb.style.top = \"50%\";\n    // Reset movement\n    moveX = 0;\n    moveY = 0;\n});\nfunction updatePlayerPositionWithJoystick() {\n    if (!joystickActive)\n        return;\n    var player = game.players[game.localPlayerId];\n    // Calculate new position based on joystick input\n    var newX = Math.min(Math.max(player.position.x + moveX * game.playerSpeed, 0), game.worldWidth - game.localPlayerSize);\n    var newY = Math.min(Math.max(player.position.y + moveY * game.playerSpeed, 0), game.worldHeight - game.localPlayerSize);\n    var msg = {\n        type: \"pos_update\",\n        data: {\n            id: game.localPlayerId,\n            position: {\n                x: newX,\n                y: newY,\n            },\n        },\n    };\n    // Send player position if moved\n    if (moveX !== 0 || moveY !== 0) {\n        conn.send(JSON.stringify(msg));\n    }\n    // Update camera position to center on the player (same as before)\n    var halfCanvasWidth = canvas.width / 2;\n    var halfCanvasHeight = canvas.height / 2;\n    camera.x = Math.max(0, Math.min(player.position.x - halfCanvasWidth + game.localPlayerSize / 2, game.worldWidth - canvas.width));\n    camera.y = Math.max(0, Math.min(player.position.y - halfCanvasHeight + game.localPlayerSize / 2, game.worldHeight - canvas.height));\n}\nfunction updatePlayerPosition() {\n    var moveX = 0;\n    var moveY = 0;\n    if (keysPressed[KEY_W] || keysPressed[KEY_UP]) {\n        if (game.players[game.localPlayerId].position.y > 0) {\n            moveY = -1;\n        }\n    }\n    if (keysPressed[KEY_S] || keysPressed[KEY_DOWN]) {\n        if (game.players[game.localPlayerId].position.y <\n            game.worldHeight - game.localPlayerSize) {\n            moveY = 1;\n        }\n    }\n    if (keysPressed[KEY_A] || keysPressed[KEY_LEFT]) {\n        if (game.players[game.localPlayerId].position.x > 0) {\n            moveX = -1;\n        }\n    }\n    if (keysPressed[KEY_D] || keysPressed[KEY_RIGHT]) {\n        if (game.players[game.localPlayerId].position.x <\n            game.worldWidth - game.localPlayerSize) {\n            moveX = 1;\n        }\n    }\n    // Normalize the movement vector if both axes are pressed\n    var length = Math.sqrt(moveX * moveX + moveY * moveY);\n    if (length > 0) {\n        moveX /= length;\n        moveY /= length;\n    }\n    var newX = Math.min(Math.max(game.players[game.localPlayerId].position.x + moveX * game.playerSpeed, 0), game.worldWidth - game.localPlayerSize);\n    var newY = Math.min(Math.max(game.players[game.localPlayerId].position.y + moveY * game.playerSpeed, 0), game.worldHeight - game.localPlayerSize);\n    var msg = {\n        type: \"pos_update\",\n        data: {\n            id: game.localPlayerId,\n            position: {\n                x: newX,\n                y: newY,\n            },\n        },\n    };\n    // Send player position if moved\n    if (moveX !== 0 || moveY !== 0) {\n        conn.send(JSON.stringify(msg));\n    }\n    // Update camera position to center on the player\n    var halfCanvasWidth = canvas.width / 2;\n    var halfCanvasHeight = canvas.height / 2;\n    camera.x = Math.max(0, Math.min(game.players[game.localPlayerId].position.x -\n        halfCanvasWidth +\n        game.localPlayerSize / 2, game.worldWidth - canvas.width));\n    camera.y = Math.max(0, Math.min(game.players[game.localPlayerId].position.y -\n        halfCanvasHeight +\n        game.localPlayerSize / 2, game.worldHeight - canvas.height));\n}\nvar ctx = canvas.getContext(\"2d\");\nfunction drawScore() {\n    ctx.fillStyle = \"white\";\n    ctx.strokeStyle = \"black\";\n    ctx.lineWidth = 2;\n    ctx.font = \"20px Arial\";\n    ctx.strokeText(\"Score: \".concat(game.score), 10, 30);\n    ctx.fillText(\"Score: \".concat(game.score), 10, 30);\n}\nfunction drawCollectableItems() {\n    ctx.fillStyle = \"orange\";\n    Object.keys(game.collectableItems).forEach(function (itemId) {\n        ctx.fillRect(game.collectableItems[+itemId].position.x - camera.x, game.collectableItems[+itemId].position.y - camera.y, game.collectableItemSize, game.collectableItemSize);\n    });\n}\nfunction drawPlayers() {\n    // Calculate camera offsets\n    var offsetX = game.players[game.localPlayerId].position.x - camera.x;\n    var offsetY = game.players[game.localPlayerId].position.y - camera.y;\n    // Draw local player\n    ctx.fillStyle = \"orange\";\n    ctx.fillRect(offsetX, offsetY, game.localPlayerSize, game.localPlayerSize);\n    // Draw other players\n    ctx.fillStyle = \"gray\";\n    Object.keys(game.players).forEach(function (playerId) {\n        if (+playerId !== game.localPlayerId) {\n            ctx.fillRect(game.players[+playerId].position.x - camera.x, game.players[+playerId].position.y - camera.y, game.localPlayerSize, game.localPlayerSize);\n        }\n    });\n}\nfunction drawBackground() {\n    var tileSize = 200;\n    var lightTileColor = \"#6b7c7f\";\n    var darkTileColor = \"#abc6cb\";\n    var startX = Math.floor(camera.x / tileSize) * tileSize;\n    var startY = Math.floor(camera.y / tileSize) * tileSize;\n    // Calculate the number of tiles to draw based on the world dimensions\n    var numTilesX = Math.ceil(game.worldWidth / tileSize) + 1; // +1 to ensure we cover the right edge\n    var numTilesY = Math.ceil(game.worldHeight / tileSize) + 1; // +1 to ensure we cover the bottom edge\n    // Loop through the number of tiles to draw\n    for (var y = 0; y < numTilesY; y++) {\n        for (var x = 0; x < numTilesX; x++) {\n            // Calculate the actual position of the tile\n            var tileX = startX + x * tileSize;\n            var tileY = startY + y * tileSize;\n            // Determine the color based on the tile's position\n            var isLightTile = (Math.floor(tileX / tileSize) + Math.floor(tileY / tileSize)) % 2 === 0;\n            ctx.fillStyle = isLightTile ? lightTileColor : darkTileColor;\n            ctx.fillRect(tileX - camera.x, tileY - camera.y, tileSize, tileSize);\n        }\n    }\n}\nfunction render() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    drawBackground();\n    drawCollectableItems();\n    drawPlayers();\n    drawScore();\n}\nfunction detectCollision() {\n    var player = game.players[game.localPlayerId];\n    var playerX = player.position.x;\n    var playerY = player.position.y;\n    var msg = {\n        type: \"collect_item\",\n        data: {\n            id: 0,\n        },\n    };\n    for (var collectableItemId in game.collectableItems) {\n        var collectableItem = game.collectableItems[collectableItemId];\n        if (playerX < collectableItem.position.x + game.collectableItemSize &&\n            playerX + game.localPlayerSize > collectableItem.position.x &&\n            playerY < collectableItem.position.y + game.collectableItemSize &&\n            playerY + game.localPlayerSize > collectableItem.position.y) {\n            console.log(\"Collision detected\");\n            msg.data.id = +collectableItemId;\n        }\n    }\n    if (msg.data.id > 0) {\n        conn.send(JSON.stringify(msg));\n    }\n}\nfunction gameLoop() {\n    if (currentGameState === GameState.RUNNING) {\n        updatePlayerPosition();\n        updatePlayerPositionWithJoystick();\n        detectCollision();\n        render();\n    }\n    requestAnimationFrame(gameLoop);\n}\nconn.onopen = function () {\n    gameLoop();\n};\n\n\n//# sourceURL=webpack:///./src/main.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/main.ts"]();
/******/ 	
/******/ })()
;